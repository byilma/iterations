---
title: "iterations_ii"
output: html_document
---


```{r setup, include=FALSE}
library(tidyverse)
library(rvest)
```


## Lists - you can put anything in a list
```{r}
l  = list (
  vec_numeric = 5:8,
vec_logical = c(T,T,F,T, F, F),
nat = matrix(1:8, nrow = 2, ncol = 4),
summary = summary(rnorm(100))
)

```


```{r}
l 
l$vec_numeric
l[[1]]

l[["vec_numeric"]][1:3]

l[["vec_numeric"]][1:3] %>% mean()
```


## `for` loop

create a new list 

```{r}

list_norm =
  list(
    a = rnorm(20, mean =3, sd =1),
     b = rnorm(30, mean =0, sd =5),
     c = rnorm(40, mean =10, sd =.2),
     d = rnorm(20, mean =-3, sd =1)
  )

```


```{r}
list_norm
list_norm[[1]]
```

Pause & get our old function. 

```{r}
mean_and_sd = function(x){
  
  if(!is.numeric(x)) {
    stop("Input must be numeric")
  }
  
  if (length(x) < 3) {
    stop("input must have 3 numbers")
  }
  
  mean_x = mean(x)
  sd_x = sd(x)
            
   tibble(
     mean = mean_x, 
      sd = sd_x
     )
}
```

I can apply this function to each list element. 

```{r}
list_norm[[1]] %>% mean_and_sd
list_norm[[2]] %>% mean_and_sd
list_norm[[3]] %>% mean_and_sd
list_norm[[4]] %>% mean_and_sd
```

But it quickly gets tedious to apply the same function over & over & over again to different things. 
This is where for_loops come into play. 

Let's use a for loop:
```{r}
output  = vector("list", length = 4) #creating an output vector that'll hold the output we're hoping to get 


#output[[1]] = mean_and_sd(list_norm[[1]]) #putting the outputs of mean_and_sd of the first list item in list_norm into the first element of our "output" vector .... but we don't want to keep doing this for every element. enter: for loops


for (i in 1:4) {
  output[[i]] = mean_and_sd(list_norm[[i]])
}

```

## let's try map!
```{r}
output2 = map(list_norm, mean_and_sd)
```
#the simplicity of map functions!! 


What if you want a dfft function

```{r}
output = map(list_norm, median)
output = map(list_norm, mean)
output = map(list_norm, IQR)
```

What if I don't want the output of the map function to not be a list!
```{r}
output = map_dbl(list_norm, median) #getting numbers "dbl" instead of lists! 

```


```{r}
output = map_df(list_norm, mean_and_sd, .id = "input") 
```

Here instead of a list of data frames I'm getting a data frame with all the elements in it!

`.id` keeps track of what the input id names are - a/b/c/d ... it gives you a column with these input ids




